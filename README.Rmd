---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "fig/README-"
)
```

# fillgaze

The goal of fillgaze is to provide helper functions for interpolating missing
eyetracking data.

## Installation

You can install fillgaze from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("tjmahr/fillgaze")
```

## Example

This package was created in response to a very strange file of eyetracking data.

```{r example, message = FALSE}
df <- readr::read_csv("inst/test-gaze.csv")
```

Here is the problem with this file:

```{r, fig.height = 3}
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)

ggplot(head(df, 40)) + 
  aes(x = Time - min(Time)) + 
  geom_hline(yintercept = 0, size = 2, color = "white") + 
  geom_point(aes(y = GazeX, color = "GazeX")) +
  geom_point(aes(y = GazeY, color = "GazeY")) + 
  labs(x = "Time (ms)", y = "Screen location (pixels)", 
       color = "Variable")
```

Every second or third point is incorrectly placed offscreen, indicated by a
negative pixel values for the gaze locations. It is physiologically impossible 
for a person's gaze to oscillate so quickly and with such magnitude (the gaze 
is tracked on a large screen display).

I would like to interpolate spans of missing data using 
neighboring points. That's the point of this package.
The steps to solve the problem involve:

- [x] Converting offscreen values into proper `NA` values.
- [x] Identifying gaps of missing values (streaks of successive `NA`s).
- [ ] Interpolating the values in a gap.

### Setting values in several columns to NA

We need to mark offscreen points as properly missing data.
`set_values_to_na()` takes a dataframe and named filtering predicates. 
Here's the basic usage.

```{r, eval = FALSE}
set_values_to_na(dataframe, {col_name} = {function to determine NA values})
```

The values that return `TRUE` for each function are replaced with `NA` values.
For example, `set_values_to_na(df, var1 = ~ .x < 0)` would:

* look for the column `var1` in the dataframe, 
* check which values of `.x < 0` are true where `.x` is a placeholder/pronoun 
  for the values in `df$var1`,
* replace those values where the test is `TRUE` with `NA`.

```{r}
library(fillgaze)
before <- head(df$GazeX)

df <- df %>% 
  set_values_to_na(
    GazeX = ~ .x < -100, 
    GazeY = ~ .x < -100, 
    LEyeCoordX = ~ .x < -.1, 
    LEyeCoordY = ~ .x < -.1,
    REyeCoordX = ~ .x < -.1, 
    REyeCoordY = ~ .x < -.1)

# Before and after on some of the GazeX values
data_frame(before, after = head(df$GazeX))
```

Now, those offscreen points will not be plotted because they are `NA`.

```{r, fig.height = 3}
last_plot() %+% head(df, 40)
```

### Finding gaps in the data

We can use `find_gaps()` to find the gaps in a column of data. `start` and `end`
are the nearest non-`NA` values. Those values are in `start_value` and
`end_value`. The number of `NA` values is in `na_size`.

```{r}
find_gaps(df, GazeX)
```

The function also respects dplyr grouping, so that e.g, false gaps are not found
between trials.

```{r}
df %>% 
  group_by(Trial) %>% 
  find_gaps(GazeX)

# todo: unit tests
```

This function is used internally. Users are not expectedly to routinely use this
function, but I cover it here because the next function for filling gaps uses
the indices and values in this dataframe.

### Interpolating values in gaps

fill_gaze_gaps

```{r}
dots <- quos(GazeX, GazeY)
max_gap <- 5
max_sd <- 2
func <- median
data <- df

df <- fill_gaze(df, GazeX, GazeY, func = median, max_gap = 5, max_sd = 2)

last_plot() %+% head(df, 40)

```

